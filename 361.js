(self.webpackChunkguitarino_github_io=self.webpackChunkguitarino_github_io||[]).push([[361],{2428:(e,r,t)=>{"use strict";t.d(r,{Z:()=>l});var n=t(3517),a=t.n(n),s=t(9306),o=t(3594),i=t(6635),p=t(4870),c=t(6777);function l(e){return(0,s.h)(o.Z,a()({},e,{class:"Markdown ".concat(e.class||""),options:{overrides:{a:i.Z,pre:s.HY,code:function(e){var r=e.class&&e.class.replace(/^lang-/,"");return r?(0,s.h)(p.Z,a()({},e,{language:r,style:c.Z})):(0,s.h)("code",e)}}}}))}},7361:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>i,menu:()=>o,title:()=>s});var n=t(2428),a=t(9306),s="You Can Create Private Properties In JS - Kirill Shestakov",o="blog";function i(e){return(0,a.h)(n.Z,{class:"AccessorPattern ".concat(e.class||"")},"# You Can Create Private Properties In JS\r\n\r\n**Note: this article was written a while ago and has since been archived, because it's no longer relevant. Nowadays, there's more proper ways of creating private properties using the hash symbol, and there's also a possibility of using TypeScript, which has compile time private properties. I'm keeping this article for history sake.**\r\n\r\nIt's very [common](https://stackoverflow.com/questions/436120/javascript-accessing-private-member-variables-from-prototype-defined-functions/436147#436147) for JavaScript developers to claim that it's impossible to create truly encapsulated properties and methods on an object **and use them on its prototype**.\r\n\r\nIn ES6, there are a few ways of easily achieving private properties without memory leaks. For example, you could use a ES6 **Symbol**:\r\n\r\n```javascript\r\n// Closure\r\nvar SomeClass = function() {\r\n    var priv_prop = Symbol();\r\n    var SomeClass = function() {\r\n        this[priv_prop] = 200;\r\n    };\r\n    SomeClass.prototype.test = function() {\r\n        console.log(this[priv_prop]);\r\n    };\r\n    return SomeClass;\r\n}();\r\nvar instance = new SomeClass();\r\ninstance.test(); // `200` logged\r\n```\r\n\r\nAlternatively, you could use a **WeakMap**:\r\n\r\n```javascript\r\n// Closure\r\nvar SomeClass = function() {\r\n    var priv_prop1 = new WeakMap();\r\n    var priv_prop2 = new WeakMap();\r\n    var SomeClass = function() {\r\n        priv_prop1.set(this, 100);\r\n        priv_prop2.set(this, 200);\r\n    };\r\n    SomeClass.prototype.test = function() {\r\n        console.log(priv_prop1.get(this));\r\n        console.log(priv_prop2.get(this));\r\n    };\r\n    return SomeClass;\r\n}();\r\nvar instance = new SomeClass();\r\ninstance.test(); // `100` and `200` logged\r\n```\r\n\r\nThe problem with the **Symbol** method is that you can still access those properties using `Object.getOwnPropertySymbols`. In either case, you would likely have to include bulky polyfills in production code.\r\n\r\nPrior to ES6, there was no *obvious* way to create private properties usable on prototype. The claim is that you either have to abandon the idea or use a memory leaky **Map** (alternatively, you could use 2 arrays). But what if I told you that there is actually a way to do this that is cross-browser, needs no polyfills or ES6, and doesn't produce memory leaks?\r\n\r\n## The idea\r\n\r\nI haven't seen this method used by anyone (**EDIT**: it was pointed out to me that I wasn't the first one to come up with this method. **[Read more here](https://medium.com/front-end-hacking/achieving-complete-data-encapsulation-in-javascript-5454a6b7410b)**), so I'd like to call it an **accessor pattern**. The idea is to create a *closure*, create a *key* inside the closure and create a *storage for private properties* that can only be accessed if the correct key is provided. Here's how you would implement it:\r\n\r\n```javascript\r\n/* Here's how you can create truly private\r\n   properties in JS and use them on prototype */\r\n\r\n// Closure\r\nvar SomeClass = function() {\r\n    var key = {};\r\n\r\n    var private = function() {\r\n        var obj = {};\r\n        return function(testkey) {\r\n            if(key === testkey) return obj;\r\n            // If the user of the class tries to access private\r\n            // properties, they won't have the access to the `key`\r\n            console.error('Cannot access private properties');\r\n            return undefined;\r\n        };\r\n    };\r\n\r\n    var SomeClass = function() {\r\n        this._ = private(); // Creates a private object\r\n        this._(key).priv_prop = 200; // this._(key) will return the private object\r\n    };\r\n\r\n    SomeClass.prototype.test = function() {\r\n        console.log(this._(key).priv_prop); // Using property from prototype\r\n    };\r\n\r\n    return SomeClass;\r\n}();\r\n\r\nvar instance = new SomeClass();\r\ninstance.test(); // `200` logged\r\n\r\nvar wrong_key = {};\r\ninstance._(wrong_key); // undefined; error logged\r\n```\r\n\r\nPretty simple, huh? `private` function creates the *private storage* and returns a private access function that will only return the *storage* if the correct *key* is provided. Then, in constructor, we assign this private access function to `this._` which can be easily used on the prototype, provided that the prototype properties also have access to the *key*. Basically, there is no way to access the *private storage* without having the correct *key*. Hence, if the user tries to call `this._` with any argument, maybe with a `wrong_key`, then the attempt will fail, error will be logged, and all the user will get is undefined.\r\n\r\nAdvantages of this method:\r\n\r\n* It's quite simple. All you need is to create a *private storage*, and you can access all private properties inline within a constructor / prototype.\r\n* It lets you create truly private properties that can be accessed from the prototype. The user of the class will not be able to access them.\r\n\r\nDisadvantage of this method:\r\n\r\n* It slightly pollutes the namespace, because you have to assign the private storage to `this._` or alike, but there's probably no other way to do this.\r\n\r\n## A problem\r\n\r\nA minor problem with this method is that, in case of prototypal inheritance, if both child and parent use the same property name for the private access function (in this example, `this._`), then the parent's private properties cannot be accessed within parent's prototype, because `this._` will refer to child's private access function. Here's what I mean,\r\n\r\n```javascript\r\n// Note: this Gist is to show a problem with accessor pattern\r\n// and inheritance. Do not use!\r\n\r\nvar private = function(key) {\r\n    var obj = {};\r\n    return function(testkey) {\r\n        if(key === testkey) return obj;\r\n        console.error('Cannot access private properties');\r\n        return undefined;\r\n    };\r\n};\r\n\r\nvar ParentClass = function() {\r\n    var key = {};\r\n    var ParentClass = function() {\r\n        this._ = private(key);\r\n        this._(key).priv_prop = 100;\r\n    };\r\n    ParentClass.prototype.parent_test = function() {\r\n        console.log(this._(key).priv_prop);\r\n    };\r\n    return ParentClass;\r\n}();\r\n\r\nvar ChildClass = function() {\r\n    var key = {};\r\n    var ChildClass = function() {\r\n        ParentClass.call(this);\r\n        this._ = private(key);\r\n        this._(key).priv_prop = 200;\r\n    };\r\n    ChildClass.prototype = Object.create(\r\n        ParentClass.prototype\r\n    );\r\n    ChildClass.prototype.test = function() {\r\n        console.log(this._(key).priv_prop);\r\n    };\r\n    return ChildClass;\r\n}();\r\n\r\nvar instance = new ChildClass();\r\ninstance.test(); // `200` is correctly logged\r\ninstance.parent_test(); // ERROR! (expected result: `100`)\r\n```\r\n\r\nWhen `instance.parent_test` is called, `this._` inside it will refer to the child's private access function, hence, the `key` will mismatch and the error will be logged. However, this problem can be quite easily solved.\r\n\r\n## The final solution\r\n\r\nThe best solution is to namespace and make sure that parent and child have different property names for their private access functions. Here's the final solution:\r\n\r\n```javascript\r\n/* Here's how you can create truly private\r\n   properties in JS and use them on prototype */\r\n\r\n// Creates private storage, secures with a key, and\r\n// returns a private access function\r\nvar private = function(key) {\r\n    var obj = {};\r\n    return function(testkey) {\r\n        if(key === testkey) return obj;\r\n        console.error('Cannot access private properties');\r\n        return undefined;\r\n    };\r\n};\r\n\r\n// Create closure\r\nvar ParentClass = function() {\r\n    var priv = '_ParentClass' + Math.random(); // Namespace\r\n    var key = {}; // Create key withing closure\r\n    var ParentClass = function() {\r\n        this[priv] = private(key); // Create private storage\r\n        this[priv](key).priv_prop = 100; // Modify any private data\r\n    };\r\n    ParentClass.prototype.parent_test = function() {\r\n        console.log(this[priv](key).priv_prop); // Access private data\r\n    };\r\n    return ParentClass;\r\n}();\r\n\r\nvar ChildClass = function() {\r\n    var priv = '_ChildClass' + Math.random();\r\n    var key = {};\r\n    var ChildClass = function() {\r\n        ParentClass.call(this);\r\n        this[priv] = private(key);\r\n        this[priv](key).priv_prop = 200;\r\n    };\r\n    ChildClass.prototype = Object.create(\r\n        ParentClass.prototype\r\n    );\r\n    ChildClass.prototype.test = function() {\r\n        console.log(this[priv](key).priv_prop);\r\n    };\r\n    return ChildClass;\r\n}();\r\n\r\nvar instance = new ChildClass();\r\ninstance.test(); // `200` logged, as expected\r\ninstance.parent_test(); // `100` logged, as expected\r\n\r\n// Yet, there's no way to access the property from outside of the closure\r\n```\r\n\r\nPretty much the only difference from the previous code snippet is that we replaced `this._` for both child and parent classes with `this[priv]`, where `priv` is namespaced and randomly generated to ensure that private access function is stored under a different property name for child and parent.\r\n\r\nAnother recommendation I can make is that you should probably secure `this[priv]` by making it non-configurable, non-enumerable and read-only:\r\n\r\n```javascript\r\nObject.defineProperty(this, priv, {\r\n    value: private(key)\r\n})\r\n```\r\n\r\nInstead of just\r\n\r\n```javascript\r\nthis[priv] = private(key)\r\n```\r\n\r\nThis will make sure that user will not be able to remove or modify `this[priv]`, which is crucial for correct private storage functioning.\r\n\r\n## Conclusion\r\n\r\nGo ahead and use **accessor pattern**! It allows you to create truly encapsulated properties and use them on a prototype. Let others know about this method so we don't continue the misconception that privacy is impossible to achieve in JavaScript. Sharing this article will also help **ðŸ˜Š**")}}}]);