(self.webpackChunkguitarino_github_io=self.webpackChunkguitarino_github_io||[]).push([[921],{2921:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>v,menu:()=>u,title:()=>h});var n=t(3517),a=t.n(n),s=t(9306),o=t(3594),i=t(6635),p=t(4870),c=t(6777);function l(e){return(0,s.h)(o.Z,a()({},e,{class:"Markdown ".concat(e.class||""),options:{overrides:{a:i.Z,pre:s.HY,code:function(e){var r=e.class&&e.class.replace(/^lang-/,"");return r?(0,s.h)(p.Z,a()({},e,{language:r,style:c.Z})):(0,s.h)("code",e)}}}}))}var h="You Can Create Private Properties In JS - Kirill Shestakov",u="blog";function v(e){return(0,s.h)(l,{class:"AccessorPattern ".concat(e.class||"")},"# You Can Create Private Properties In JS\r\n\r\nIt's very [common](https://stackoverflow.com/questions/436120/javascript-accessing-private-member-variables-from-prototype-defined-functions/436147#436147) for JavaScript developers to claim that it's impossible to create truly encapsulated properties and methods on an object **and use them on its prototype**.\r\n\r\nIn ES6, there are a few ways of easily achieving private properties without memory leaks. For example, you could use a ES6 **Symbol**:\r\n\r\n```javascript\r\n// Closure\r\nvar SomeClass = function() {\r\n    var priv_prop = Symbol();\r\n    var SomeClass = function() {\r\n        this[priv_prop] = 200;\r\n    };\r\n    SomeClass.prototype.test = function() {\r\n        console.log(this[priv_prop]);\r\n    };\r\n    return SomeClass;\r\n}();\r\nvar instance = new SomeClass();\r\ninstance.test(); // `200` logged\r\n```\r\n\r\nAlternatively, you could use a **WeakMap**:\r\n\r\n```javascript\r\n// Closure\r\nvar SomeClass = function() {\r\n    var priv_prop1 = new WeakMap();\r\n    var priv_prop2 = new WeakMap();\r\n    var SomeClass = function() {\r\n        priv_prop1.set(this, 100);\r\n        priv_prop2.set(this, 200);\r\n    };\r\n    SomeClass.prototype.test = function() {\r\n        console.log(priv_prop1.get(this));\r\n        console.log(priv_prop2.get(this));\r\n    };\r\n    return SomeClass;\r\n}();\r\nvar instance = new SomeClass();\r\ninstance.test(); // `100` and `200` logged\r\n```\r\n\r\nThe problem with the **Symbol** method is that you can still access those properties using `Object.getOwnPropertySymbols`. In either case, you would likely have to include bulky polyfills in production code.\r\n\r\nPrior to ES6, there was no *obvious* way to create private properties usable on prototype. The claim is that you either have to abandon the idea or use a memory leaky **Map** (alternatively, you could use 2 arrays). But what if I told you that there is actually a way to do this that is cross-browser, needs no polyfills or ES6, and doesn't produce memory leaks?\r\n\r\n## The idea\r\n\r\nI haven't seen this method used by anyone (**EDIT**: it was pointed out to me that I wasn't the first one to come up with this method. **[Read more here](https://medium.com/front-end-hacking/achieving-complete-data-encapsulation-in-javascript-5454a6b7410b)**), so I'd like to call it an **accessor pattern**. The idea is to create a *closure*, create a *key* inside the closure and create a *storage for private properties* that can only be accessed if the correct key is provided. Here's how you would implement it:\r\n\r\n```javascript\r\n/* Here's how you can create truly private\r\n   properties in JS and use them on prototype */\r\n\r\n// Closure\r\nvar SomeClass = function() {\r\n    var key = {};\r\n\r\n    var private = function() {\r\n        var obj = {};\r\n        return function(testkey) {\r\n            if(key === testkey) return obj;\r\n            // If the user of the class tries to access private\r\n            // properties, they won't have the access to the `key`\r\n            console.error('Cannot access private properties');\r\n            return undefined;\r\n        };\r\n    };\r\n\r\n    var SomeClass = function() {\r\n        this._ = private(); // Creates a private object\r\n        this._(key).priv_prop = 200; // this._(key) will return the private object\r\n    };\r\n\r\n    SomeClass.prototype.test = function() {\r\n        console.log(this._(key).priv_prop); // Using property from prototype\r\n    };\r\n\r\n    return SomeClass;\r\n}();\r\n\r\nvar instance = new SomeClass();\r\ninstance.test(); // `200` logged\r\n\r\nvar wrong_key = {};\r\ninstance._(wrong_key); // undefined; error logged\r\n```\r\n\r\nPretty simple, huh? `private` function creates the *private storage* and returns a private access function that will only return the *storage* if the correct *key* is provided. Then, in constructor, we assign this private access function to `this._` which can be easily used on the prototype, provided that the prototype properties also have access to the *key*. Basically, there is no way to access the *private storage* without having the correct *key*. Hence, if the user tries to call `this._` with any argument, maybe with a `wrong_key`, then the attempt will fail, error will be logged, and all the user will get is undefined.\r\n\r\nAdvantages of this method:\r\n\r\n* It's quite simple. All you need is to create a *private storage*, and you can access all private properties inline within a constructor / prototype.\r\n* It lets you create truly private properties that can be accessed from the prototype. The user of the class will not be able to access them.\r\n\r\nDisadvantage of this method:\r\n\r\n* It slightly pollutes the namespace, because you have to assign the private storage to `this._` or alike, but there's probably no other way to do this.\r\n\r\n## A problem\r\n\r\nA minor problem with this method is that, in case of prototypal inheritance, if both child and parent use the same property name for the private access function (in this example, `this._`), then the parent's private properties cannot be accessed within parent's prototype, because `this._` will refer to child's private access function. Here's what I mean,\r\n\r\n```javascript\r\n// Note: this Gist is to show a problem with accessor pattern\r\n// and inheritance. Do not use!\r\n\r\nvar private = function(key) {\r\n    var obj = {};\r\n    return function(testkey) {\r\n        if(key === testkey) return obj;\r\n        console.error('Cannot access private properties');\r\n        return undefined;\r\n    };\r\n};\r\n\r\nvar ParentClass = function() {\r\n    var key = {};\r\n    var ParentClass = function() {\r\n        this._ = private(key);\r\n        this._(key).priv_prop = 100;\r\n    };\r\n    ParentClass.prototype.parent_test = function() {\r\n        console.log(this._(key).priv_prop);\r\n    };\r\n    return ParentClass;\r\n}();\r\n\r\nvar ChildClass = function() {\r\n    var key = {};\r\n    var ChildClass = function() {\r\n        ParentClass.call(this);\r\n        this._ = private(key);\r\n        this._(key).priv_prop = 200;\r\n    };\r\n    ChildClass.prototype = Object.create(\r\n        ParentClass.prototype\r\n    );\r\n    ChildClass.prototype.test = function() {\r\n        console.log(this._(key).priv_prop);\r\n    };\r\n    return ChildClass;\r\n}();\r\n\r\nvar instance = new ChildClass();\r\ninstance.test(); // `200` is correctly logged\r\ninstance.parent_test(); // ERROR! (expected result: `100`)\r\n```\r\n\r\nWhen `instance.parent_test` is called, `this._` inside it will refer to the child's private access function, hence, the `key` will mismatch and the error will be logged. However, this problem can be quite easily solved.\r\n\r\n## The final solution\r\n\r\nThe best solution is to namespace and make sure that parent and child have different property names for their private access functions. Here's the final solution:\r\n\r\n```javascript\r\n/* Here's how you can create truly private\r\n   properties in JS and use them on prototype */\r\n\r\n// Creates private storage, secures with a key, and\r\n// returns a private access function\r\nvar private = function(key) {\r\n    var obj = {};\r\n    return function(testkey) {\r\n        if(key === testkey) return obj;\r\n        console.error('Cannot access private properties');\r\n        return undefined;\r\n    };\r\n};\r\n\r\n// Create closure\r\nvar ParentClass = function() {\r\n    var priv = '_ParentClass' + Math.random(); // Namespace\r\n    var key = {}; // Create key withing closure\r\n    var ParentClass = function() {\r\n        this[priv] = private(key); // Create private storage\r\n        this[priv](key).priv_prop = 100; // Modify any private data\r\n    };\r\n    ParentClass.prototype.parent_test = function() {\r\n        console.log(this[priv](key).priv_prop); // Access private data\r\n    };\r\n    return ParentClass;\r\n}();\r\n\r\nvar ChildClass = function() {\r\n    var priv = '_ChildClass' + Math.random();\r\n    var key = {};\r\n    var ChildClass = function() {\r\n        ParentClass.call(this);\r\n        this[priv] = private(key);\r\n        this[priv](key).priv_prop = 200;\r\n    };\r\n    ChildClass.prototype = Object.create(\r\n        ParentClass.prototype\r\n    );\r\n    ChildClass.prototype.test = function() {\r\n        console.log(this[priv](key).priv_prop);\r\n    };\r\n    return ChildClass;\r\n}();\r\n\r\nvar instance = new ChildClass();\r\ninstance.test(); // `200` logged, as expected\r\ninstance.parent_test(); // `100` logged, as expected\r\n\r\n// Yet, there's no way to access the property from outside of the closure\r\n```\r\n\r\nPretty much the only difference from the previous code snippet is that we replaced `this._` for both child and parent classes with `this[priv]`, where `priv` is namespaced and randomly generated to ensure that private access function is stored under a different property name for child and parent.\r\n\r\nAnother recommendation I can make is that you should probably secure `this[priv]` by making it non-configurable, non-enumerable and read-only:\r\n\r\n```javascript\r\nObject.defineProperty(this, priv, {\r\n    value: private(key)\r\n})\r\n```\r\n\r\nInstead of just\r\n\r\n```javascript\r\nthis[priv] = private(key)\r\n```\r\n\r\nThis will make sure that user will not be able to remove or modify `this[priv]`, which is crucial for correct private storage functioning.\r\n\r\n## Conclusion\r\n\r\nGo ahead and use **accessor pattern**! It allows you to create truly encapsulated properties and use them on a prototype. Let others know about this method so we don't continue the misconception that privacy is impossible to achieve in JavaScript. Sharing this article will also help **😊**")}}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWl0YXJpbm8uZ2l0aHViLmlvLy4vc3JjL2NvbXBvbmVudHMvTWFya2Rvd24udHN4Iiwid2VicGFjazovL2d1aXRhcmluby5naXRodWIuaW8vLi9zcmMvcGFnZXMvQWNjZXNzb3JQYXR0ZXJuLnRzeCIsIndlYnBhY2s6Ly9ndWl0YXJpbm8uZ2l0aHViLmlvLy4vY29udGVudC9BY2Nlc3NvclBhdHRlcm4ubWQiXSwibmFtZXMiOlsiTWFya2Rvd24iLCJwcm9wcyIsImNsYXNzIiwib3B0aW9ucyIsIm92ZXJyaWRlcyIsImEiLCJMaW5rIiwicHJlIiwiRnJhZ21lbnQiLCJjb2RlIiwibGFuZ3VhZ2UiLCJyZXBsYWNlIiwic3R5bGUiLCJtb25va2FpU3VibGltZSIsInRpdGxlIiwibWVudSIsIkFjY2Vzc29yUGF0dGVybiJdLCJtYXBwaW5ncyI6InVQQU1lLFNBQVNBLEVBQVNDLEdBQ2hDLE9BQU8sT0FBQyxJQUFELE9BQXFCQSxFQUFyQixDQUE0QkMsTUFBQSxtQkFBbUJELEVBQUssT0FBTCxJQUFxQkUsUUFBUyxDQUNuRkMsVUFBVyxDQUNWQyxFQUFHQyxJQUNIQyxJQUFLQyxLQUNMQyxLQUFNLFNBQUFSLEdBQ0wsSUFBTVMsRUFBV1QsRUFBSyxPQUFVQSxFQUFLLE1BQU9VLFFBQVEsU0FBVSxJQUM5RCxPQUFJRCxHQUNJLE9BQUMsSUFBRCxPQUNGVCxFQURFLENBRU5TLFNBQVVBLEVBQ1ZFLE1BQU9DLFFBSUQsY0FBVVosU0NqQmYsSUFBTWEsRUFBUSw2REFFUkMsRUFBTyxPQUVMLFNBQVNDLEVBQWdCZixHQUN2QyxPQUFPLE9BQUNELEVBQUQsQ0FBVUUsTUFBQSwwQkFBMEJELEVBQUssT0FBTCxLQ1Q1QyIsImZpbGUiOiI5MjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGcmFnbWVudCwgaCB9IGZyb20gJ3ByZWFjdCc7XHJcbmltcG9ydCBNYXJrZG93bkxpYnJhcnkgZnJvbSAnbWFya2Rvd24tdG8tanN4JztcclxuaW1wb3J0IExpbmsgZnJvbSAnQGNvbXBvbmVudHMvTGluayc7XHJcbmltcG9ydCBTeW50YXhIaWdobGlnaHRlciBmcm9tICdyZWFjdC1zeW50YXgtaGlnaGxpZ2h0ZXInO1xyXG5pbXBvcnQgeyBtb25va2FpU3VibGltZSB9IGZyb20gJ3JlYWN0LXN5bnRheC1oaWdobGlnaHRlci9kaXN0L2VzbS9zdHlsZXMvaGxqcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXJrZG93bihwcm9wczogYW55KSB7XHJcblx0cmV0dXJuIDxNYXJrZG93bkxpYnJhcnkgey4uLnByb3BzfSBjbGFzcz17YE1hcmtkb3duICR7cHJvcHMuY2xhc3MgfHwgYGB9YH0gb3B0aW9ucz17e1xyXG5cdFx0b3ZlcnJpZGVzOiB7XHJcblx0XHRcdGE6IExpbmssXHJcblx0XHRcdHByZTogRnJhZ21lbnQsXHJcblx0XHRcdGNvZGU6IHByb3BzID0+IHtcclxuXHRcdFx0XHRjb25zdCBsYW5ndWFnZSA9IHByb3BzLmNsYXNzICYmIHByb3BzLmNsYXNzLnJlcGxhY2UoL15sYW5nLS8sICcnKTtcclxuXHRcdFx0XHRpZiAobGFuZ3VhZ2UpIHtcclxuXHRcdFx0XHRcdHJldHVybiA8U3ludGF4SGlnaGxpZ2h0ZXJcclxuXHRcdFx0XHRcdFx0ey4uLnByb3BzfVxyXG5cdFx0XHRcdFx0XHRsYW5ndWFnZT17bGFuZ3VhZ2V9XHJcblx0XHRcdFx0XHRcdHN0eWxlPXttb25va2FpU3VibGltZX1cclxuXHRcdFx0XHRcdC8+O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiA8Y29kZSB7Li4ucHJvcHN9IC8+O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdH0sXHJcblx0fX0gLz47XHJcbn0iLCJpbXBvcnQgTWFya2Rvd24gZnJvbSAnQGNvbXBvbmVudHMvTWFya2Rvd24nO1xyXG5pbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcclxuaW1wb3J0IGNvbnRlbnQgZnJvbSAnQGNvbnRlbnQvQWNjZXNzb3JQYXR0ZXJuLm1kJztcclxuXHJcbmV4cG9ydCBjb25zdCB0aXRsZSA9ICdZb3UgQ2FuIENyZWF0ZSBQcml2YXRlIFByb3BlcnRpZXMgSW4gSlMgLSBLaXJpbGwgU2hlc3Rha292JztcclxuXHJcbmV4cG9ydCBjb25zdCBtZW51ID0gJ2Jsb2cnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWNjZXNzb3JQYXR0ZXJuKHByb3BzOiB7IGNsYXNzPzogc3RyaW5nIH0pIHtcclxuXHRyZXR1cm4gPE1hcmtkb3duIGNsYXNzPXtgQWNjZXNzb3JQYXR0ZXJuICR7cHJvcHMuY2xhc3MgfHwgYGB9YH0+XHJcblx0XHR7Y29udGVudH1cclxuXHQ8L01hcmtkb3duPjtcclxufSIsImV4cG9ydCBkZWZhdWx0IFwiIyBZb3UgQ2FuIENyZWF0ZSBQcml2YXRlIFByb3BlcnRpZXMgSW4gSlNcXHJcXG5cXHJcXG5JdCdzIHZlcnkgW2NvbW1vbl0oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDM2MTIwL2phdmFzY3JpcHQtYWNjZXNzaW5nLXByaXZhdGUtbWVtYmVyLXZhcmlhYmxlcy1mcm9tLXByb3RvdHlwZS1kZWZpbmVkLWZ1bmN0aW9ucy80MzYxNDcjNDM2MTQ3KSBmb3IgSmF2YVNjcmlwdCBkZXZlbG9wZXJzIHRvIGNsYWltIHRoYXQgaXQncyBpbXBvc3NpYmxlIHRvIGNyZWF0ZSB0cnVseSBlbmNhcHN1bGF0ZWQgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvbiBhbiBvYmplY3QgKiphbmQgdXNlIHRoZW0gb24gaXRzIHByb3RvdHlwZSoqLlxcclxcblxcclxcbkluIEVTNiwgdGhlcmUgYXJlIGEgZmV3IHdheXMgb2YgZWFzaWx5IGFjaGlldmluZyBwcml2YXRlIHByb3BlcnRpZXMgd2l0aG91dCBtZW1vcnkgbGVha3MuIEZvciBleGFtcGxlLCB5b3UgY291bGQgdXNlIGEgRVM2ICoqU3ltYm9sKio6XFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbi8vIENsb3N1cmVcXHJcXG52YXIgU29tZUNsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgIHZhciBwcml2X3Byb3AgPSBTeW1ib2woKTtcXHJcXG4gICAgdmFyIFNvbWVDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgdGhpc1twcml2X3Byb3BdID0gMjAwO1xcclxcbiAgICB9O1xcclxcbiAgICBTb21lQ2xhc3MucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXNbcHJpdl9wcm9wXSk7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBTb21lQ2xhc3M7XFxyXFxufSgpO1xcclxcbnZhciBpbnN0YW5jZSA9IG5ldyBTb21lQ2xhc3MoKTtcXHJcXG5pbnN0YW5jZS50ZXN0KCk7IC8vIGAyMDBgIGxvZ2dlZFxcclxcbmBgYFxcclxcblxcclxcbkFsdGVybmF0aXZlbHksIHlvdSBjb3VsZCB1c2UgYSAqKldlYWtNYXAqKjpcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gQ2xvc3VyZVxcclxcbnZhciBTb21lQ2xhc3MgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgdmFyIHByaXZfcHJvcDEgPSBuZXcgV2Vha01hcCgpO1xcclxcbiAgICB2YXIgcHJpdl9wcm9wMiA9IG5ldyBXZWFrTWFwKCk7XFxyXFxuICAgIHZhciBTb21lQ2xhc3MgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIHByaXZfcHJvcDEuc2V0KHRoaXMsIDEwMCk7XFxyXFxuICAgICAgICBwcml2X3Byb3AyLnNldCh0aGlzLCAyMDApO1xcclxcbiAgICB9O1xcclxcbiAgICBTb21lQ2xhc3MucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHByaXZfcHJvcDEuZ2V0KHRoaXMpKTtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHByaXZfcHJvcDIuZ2V0KHRoaXMpKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgcmV0dXJuIFNvbWVDbGFzcztcXHJcXG59KCk7XFxyXFxudmFyIGluc3RhbmNlID0gbmV3IFNvbWVDbGFzcygpO1xcclxcbmluc3RhbmNlLnRlc3QoKTsgLy8gYDEwMGAgYW5kIGAyMDBgIGxvZ2dlZFxcclxcbmBgYFxcclxcblxcclxcblRoZSBwcm9ibGVtIHdpdGggdGhlICoqU3ltYm9sKiogbWV0aG9kIGlzIHRoYXQgeW91IGNhbiBzdGlsbCBhY2Nlc3MgdGhvc2UgcHJvcGVydGllcyB1c2luZyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AuIEluIGVpdGhlciBjYXNlLCB5b3Ugd291bGQgbGlrZWx5IGhhdmUgdG8gaW5jbHVkZSBidWxreSBwb2x5ZmlsbHMgaW4gcHJvZHVjdGlvbiBjb2RlLlxcclxcblxcclxcblByaW9yIHRvIEVTNiwgdGhlcmUgd2FzIG5vICpvYnZpb3VzKiB3YXkgdG8gY3JlYXRlIHByaXZhdGUgcHJvcGVydGllcyB1c2FibGUgb24gcHJvdG90eXBlLiBUaGUgY2xhaW0gaXMgdGhhdCB5b3UgZWl0aGVyIGhhdmUgdG8gYWJhbmRvbiB0aGUgaWRlYSBvciB1c2UgYSBtZW1vcnkgbGVha3kgKipNYXAqKiAoYWx0ZXJuYXRpdmVseSwgeW91IGNvdWxkIHVzZSAyIGFycmF5cykuIEJ1dCB3aGF0IGlmIEkgdG9sZCB5b3UgdGhhdCB0aGVyZSBpcyBhY3R1YWxseSBhIHdheSB0byBkbyB0aGlzIHRoYXQgaXMgY3Jvc3MtYnJvd3NlciwgbmVlZHMgbm8gcG9seWZpbGxzIG9yIEVTNiwgYW5kIGRvZXNuJ3QgcHJvZHVjZSBtZW1vcnkgbGVha3M/XFxyXFxuXFxyXFxuIyMgVGhlIGlkZWFcXHJcXG5cXHJcXG5JIGhhdmVuJ3Qgc2VlbiB0aGlzIG1ldGhvZCB1c2VkIGJ5IGFueW9uZSAoKipFRElUKio6IGl0IHdhcyBwb2ludGVkIG91dCB0byBtZSB0aGF0IEkgd2Fzbid0IHRoZSBmaXJzdCBvbmUgdG8gY29tZSB1cCB3aXRoIHRoaXMgbWV0aG9kLiAqKltSZWFkIG1vcmUgaGVyZV0oaHR0cHM6Ly9tZWRpdW0uY29tL2Zyb250LWVuZC1oYWNraW5nL2FjaGlldmluZy1jb21wbGV0ZS1kYXRhLWVuY2Fwc3VsYXRpb24taW4tamF2YXNjcmlwdC01NDU0YTZiNzQxMGIpKiopLCBzbyBJJ2QgbGlrZSB0byBjYWxsIGl0IGFuICoqYWNjZXNzb3IgcGF0dGVybioqLiBUaGUgaWRlYSBpcyB0byBjcmVhdGUgYSAqY2xvc3VyZSosIGNyZWF0ZSBhICprZXkqIGluc2lkZSB0aGUgY2xvc3VyZSBhbmQgY3JlYXRlIGEgKnN0b3JhZ2UgZm9yIHByaXZhdGUgcHJvcGVydGllcyogdGhhdCBjYW4gb25seSBiZSBhY2Nlc3NlZCBpZiB0aGUgY29ycmVjdCBrZXkgaXMgcHJvdmlkZWQuIEhlcmUncyBob3cgeW91IHdvdWxkIGltcGxlbWVudCBpdDpcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLyogSGVyZSdzIGhvdyB5b3UgY2FuIGNyZWF0ZSB0cnVseSBwcml2YXRlXFxyXFxuICAgcHJvcGVydGllcyBpbiBKUyBhbmQgdXNlIHRoZW0gb24gcHJvdG90eXBlICovXFxyXFxuXFxyXFxuLy8gQ2xvc3VyZVxcclxcbnZhciBTb21lQ2xhc3MgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgdmFyIGtleSA9IHt9O1xcclxcblxcclxcbiAgICB2YXIgcHJpdmF0ZSA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xcclxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRlc3RrZXkpIHtcXHJcXG4gICAgICAgICAgICBpZihrZXkgPT09IHRlc3RrZXkpIHJldHVybiBvYmo7XFxyXFxuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgb2YgdGhlIGNsYXNzIHRyaWVzIHRvIGFjY2VzcyBwcml2YXRlXFxyXFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcywgdGhleSB3b24ndCBoYXZlIHRoZSBhY2Nlc3MgdG8gdGhlIGBrZXlgXFxyXFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGFjY2VzcyBwcml2YXRlIHByb3BlcnRpZXMnKTtcXHJcXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcclxcbiAgICAgICAgfTtcXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgdmFyIFNvbWVDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgdGhpcy5fID0gcHJpdmF0ZSgpOyAvLyBDcmVhdGVzIGEgcHJpdmF0ZSBvYmplY3RcXHJcXG4gICAgICAgIHRoaXMuXyhrZXkpLnByaXZfcHJvcCA9IDIwMDsgLy8gdGhpcy5fKGtleSkgd2lsbCByZXR1cm4gdGhlIHByaXZhdGUgb2JqZWN0XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIFNvbWVDbGFzcy5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5fKGtleSkucHJpdl9wcm9wKTsgLy8gVXNpbmcgcHJvcGVydHkgZnJvbSBwcm90b3R5cGVcXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIFNvbWVDbGFzcztcXHJcXG59KCk7XFxyXFxuXFxyXFxudmFyIGluc3RhbmNlID0gbmV3IFNvbWVDbGFzcygpO1xcclxcbmluc3RhbmNlLnRlc3QoKTsgLy8gYDIwMGAgbG9nZ2VkXFxyXFxuXFxyXFxudmFyIHdyb25nX2tleSA9IHt9O1xcclxcbmluc3RhbmNlLl8od3Jvbmdfa2V5KTsgLy8gdW5kZWZpbmVkOyBlcnJvciBsb2dnZWRcXHJcXG5gYGBcXHJcXG5cXHJcXG5QcmV0dHkgc2ltcGxlLCBodWg/IGBwcml2YXRlYCBmdW5jdGlvbiBjcmVhdGVzIHRoZSAqcHJpdmF0ZSBzdG9yYWdlKiBhbmQgcmV0dXJucyBhIHByaXZhdGUgYWNjZXNzIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IHJldHVybiB0aGUgKnN0b3JhZ2UqIGlmIHRoZSBjb3JyZWN0ICprZXkqIGlzIHByb3ZpZGVkLiBUaGVuLCBpbiBjb25zdHJ1Y3Rvciwgd2UgYXNzaWduIHRoaXMgcHJpdmF0ZSBhY2Nlc3MgZnVuY3Rpb24gdG8gYHRoaXMuX2Agd2hpY2ggY2FuIGJlIGVhc2lseSB1c2VkIG9uIHRoZSBwcm90b3R5cGUsIHByb3ZpZGVkIHRoYXQgdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFsc28gaGF2ZSBhY2Nlc3MgdG8gdGhlICprZXkqLiBCYXNpY2FsbHksIHRoZXJlIGlzIG5vIHdheSB0byBhY2Nlc3MgdGhlICpwcml2YXRlIHN0b3JhZ2UqIHdpdGhvdXQgaGF2aW5nIHRoZSBjb3JyZWN0ICprZXkqLiBIZW5jZSwgaWYgdGhlIHVzZXIgdHJpZXMgdG8gY2FsbCBgdGhpcy5fYCB3aXRoIGFueSBhcmd1bWVudCwgbWF5YmUgd2l0aCBhIGB3cm9uZ19rZXlgLCB0aGVuIHRoZSBhdHRlbXB0IHdpbGwgZmFpbCwgZXJyb3Igd2lsbCBiZSBsb2dnZWQsIGFuZCBhbGwgdGhlIHVzZXIgd2lsbCBnZXQgaXMgdW5kZWZpbmVkLlxcclxcblxcclxcbkFkdmFudGFnZXMgb2YgdGhpcyBtZXRob2Q6XFxyXFxuXFxyXFxuKiBJdCdzIHF1aXRlIHNpbXBsZS4gQWxsIHlvdSBuZWVkIGlzIHRvIGNyZWF0ZSBhICpwcml2YXRlIHN0b3JhZ2UqLCBhbmQgeW91IGNhbiBhY2Nlc3MgYWxsIHByaXZhdGUgcHJvcGVydGllcyBpbmxpbmUgd2l0aGluIGEgY29uc3RydWN0b3IgLyBwcm90b3R5cGUuXFxyXFxuKiBJdCBsZXRzIHlvdSBjcmVhdGUgdHJ1bHkgcHJpdmF0ZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIGZyb20gdGhlIHByb3RvdHlwZS4gVGhlIHVzZXIgb2YgdGhlIGNsYXNzIHdpbGwgbm90IGJlIGFibGUgdG8gYWNjZXNzIHRoZW0uXFxyXFxuXFxyXFxuRGlzYWR2YW50YWdlIG9mIHRoaXMgbWV0aG9kOlxcclxcblxcclxcbiogSXQgc2xpZ2h0bHkgcG9sbHV0ZXMgdGhlIG5hbWVzcGFjZSwgYmVjYXVzZSB5b3UgaGF2ZSB0byBhc3NpZ24gdGhlIHByaXZhdGUgc3RvcmFnZSB0byBgdGhpcy5fYCBvciBhbGlrZSwgYnV0IHRoZXJlJ3MgcHJvYmFibHkgbm8gb3RoZXIgd2F5IHRvIGRvIHRoaXMuXFxyXFxuXFxyXFxuIyMgQSBwcm9ibGVtXFxyXFxuXFxyXFxuQSBtaW5vciBwcm9ibGVtIHdpdGggdGhpcyBtZXRob2QgaXMgdGhhdCwgaW4gY2FzZSBvZiBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCBpZiBib3RoIGNoaWxkIGFuZCBwYXJlbnQgdXNlIHRoZSBzYW1lIHByb3BlcnR5IG5hbWUgZm9yIHRoZSBwcml2YXRlIGFjY2VzcyBmdW5jdGlvbiAoaW4gdGhpcyBleGFtcGxlLCBgdGhpcy5fYCksIHRoZW4gdGhlIHBhcmVudCdzIHByaXZhdGUgcHJvcGVydGllcyBjYW5ub3QgYmUgYWNjZXNzZWQgd2l0aGluIHBhcmVudCdzIHByb3RvdHlwZSwgYmVjYXVzZSBgdGhpcy5fYCB3aWxsIHJlZmVyIHRvIGNoaWxkJ3MgcHJpdmF0ZSBhY2Nlc3MgZnVuY3Rpb24uIEhlcmUncyB3aGF0IEkgbWVhbixcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gTm90ZTogdGhpcyBHaXN0IGlzIHRvIHNob3cgYSBwcm9ibGVtIHdpdGggYWNjZXNzb3IgcGF0dGVyblxcclxcbi8vIGFuZCBpbmhlcml0YW5jZS4gRG8gbm90IHVzZSFcXHJcXG5cXHJcXG52YXIgcHJpdmF0ZSA9IGZ1bmN0aW9uKGtleSkge1xcclxcbiAgICB2YXIgb2JqID0ge307XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbih0ZXN0a2V5KSB7XFxyXFxuICAgICAgICBpZihrZXkgPT09IHRlc3RrZXkpIHJldHVybiBvYmo7XFxyXFxuICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgYWNjZXNzIHByaXZhdGUgcHJvcGVydGllcycpO1xcclxcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXHJcXG4gICAgfTtcXHJcXG59O1xcclxcblxcclxcbnZhciBQYXJlbnRDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICB2YXIga2V5ID0ge307XFxyXFxuICAgIHZhciBQYXJlbnRDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgdGhpcy5fID0gcHJpdmF0ZShrZXkpO1xcclxcbiAgICAgICAgdGhpcy5fKGtleSkucHJpdl9wcm9wID0gMTAwO1xcclxcbiAgICB9O1xcclxcbiAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGUucGFyZW50X3Rlc3QgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuXyhrZXkpLnByaXZfcHJvcCk7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBQYXJlbnRDbGFzcztcXHJcXG59KCk7XFxyXFxuXFxyXFxudmFyIENoaWxkQ2xhc3MgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgdmFyIGtleSA9IHt9O1xcclxcbiAgICB2YXIgQ2hpbGRDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgUGFyZW50Q2xhc3MuY2FsbCh0aGlzKTtcXHJcXG4gICAgICAgIHRoaXMuXyA9IHByaXZhdGUoa2V5KTtcXHJcXG4gICAgICAgIHRoaXMuXyhrZXkpLnByaXZfcHJvcCA9IDIwMDtcXHJcXG4gICAgfTtcXHJcXG4gICAgQ2hpbGRDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxcclxcbiAgICAgICAgUGFyZW50Q2xhc3MucHJvdG90eXBlXFxyXFxuICAgICk7XFxyXFxuICAgIENoaWxkQ2xhc3MucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuXyhrZXkpLnByaXZfcHJvcCk7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBDaGlsZENsYXNzO1xcclxcbn0oKTtcXHJcXG5cXHJcXG52YXIgaW5zdGFuY2UgPSBuZXcgQ2hpbGRDbGFzcygpO1xcclxcbmluc3RhbmNlLnRlc3QoKTsgLy8gYDIwMGAgaXMgY29ycmVjdGx5IGxvZ2dlZFxcclxcbmluc3RhbmNlLnBhcmVudF90ZXN0KCk7IC8vIEVSUk9SISAoZXhwZWN0ZWQgcmVzdWx0OiBgMTAwYClcXHJcXG5gYGBcXHJcXG5cXHJcXG5XaGVuIGBpbnN0YW5jZS5wYXJlbnRfdGVzdGAgaXMgY2FsbGVkLCBgdGhpcy5fYCBpbnNpZGUgaXQgd2lsbCByZWZlciB0byB0aGUgY2hpbGQncyBwcml2YXRlIGFjY2VzcyBmdW5jdGlvbiwgaGVuY2UsIHRoZSBga2V5YCB3aWxsIG1pc21hdGNoIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSBsb2dnZWQuIEhvd2V2ZXIsIHRoaXMgcHJvYmxlbSBjYW4gYmUgcXVpdGUgZWFzaWx5IHNvbHZlZC5cXHJcXG5cXHJcXG4jIyBUaGUgZmluYWwgc29sdXRpb25cXHJcXG5cXHJcXG5UaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBuYW1lc3BhY2UgYW5kIG1ha2Ugc3VyZSB0aGF0IHBhcmVudCBhbmQgY2hpbGQgaGF2ZSBkaWZmZXJlbnQgcHJvcGVydHkgbmFtZXMgZm9yIHRoZWlyIHByaXZhdGUgYWNjZXNzIGZ1bmN0aW9ucy4gSGVyZSdzIHRoZSBmaW5hbCBzb2x1dGlvbjpcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLyogSGVyZSdzIGhvdyB5b3UgY2FuIGNyZWF0ZSB0cnVseSBwcml2YXRlXFxyXFxuICAgcHJvcGVydGllcyBpbiBKUyBhbmQgdXNlIHRoZW0gb24gcHJvdG90eXBlICovXFxyXFxuXFxyXFxuLy8gQ3JlYXRlcyBwcml2YXRlIHN0b3JhZ2UsIHNlY3VyZXMgd2l0aCBhIGtleSwgYW5kXFxyXFxuLy8gcmV0dXJucyBhIHByaXZhdGUgYWNjZXNzIGZ1bmN0aW9uXFxyXFxudmFyIHByaXZhdGUgPSBmdW5jdGlvbihrZXkpIHtcXHJcXG4gICAgdmFyIG9iaiA9IHt9O1xcclxcbiAgICByZXR1cm4gZnVuY3Rpb24odGVzdGtleSkge1xcclxcbiAgICAgICAgaWYoa2V5ID09PSB0ZXN0a2V5KSByZXR1cm4gb2JqO1xcclxcbiAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGFjY2VzcyBwcml2YXRlIHByb3BlcnRpZXMnKTtcXHJcXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxyXFxuICAgIH07XFxyXFxufTtcXHJcXG5cXHJcXG4vLyBDcmVhdGUgY2xvc3VyZVxcclxcbnZhciBQYXJlbnRDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICB2YXIgcHJpdiA9ICdfUGFyZW50Q2xhc3MnICsgTWF0aC5yYW5kb20oKTsgLy8gTmFtZXNwYWNlXFxyXFxuICAgIHZhciBrZXkgPSB7fTsgLy8gQ3JlYXRlIGtleSB3aXRoaW5nIGNsb3N1cmVcXHJcXG4gICAgdmFyIFBhcmVudENsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICB0aGlzW3ByaXZdID0gcHJpdmF0ZShrZXkpOyAvLyBDcmVhdGUgcHJpdmF0ZSBzdG9yYWdlXFxyXFxuICAgICAgICB0aGlzW3ByaXZdKGtleSkucHJpdl9wcm9wID0gMTAwOyAvLyBNb2RpZnkgYW55IHByaXZhdGUgZGF0YVxcclxcbiAgICB9O1xcclxcbiAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGUucGFyZW50X3Rlc3QgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXNbcHJpdl0oa2V5KS5wcml2X3Byb3ApOyAvLyBBY2Nlc3MgcHJpdmF0ZSBkYXRhXFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBQYXJlbnRDbGFzcztcXHJcXG59KCk7XFxyXFxuXFxyXFxudmFyIENoaWxkQ2xhc3MgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgdmFyIHByaXYgPSAnX0NoaWxkQ2xhc3MnICsgTWF0aC5yYW5kb20oKTtcXHJcXG4gICAgdmFyIGtleSA9IHt9O1xcclxcbiAgICB2YXIgQ2hpbGRDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgUGFyZW50Q2xhc3MuY2FsbCh0aGlzKTtcXHJcXG4gICAgICAgIHRoaXNbcHJpdl0gPSBwcml2YXRlKGtleSk7XFxyXFxuICAgICAgICB0aGlzW3ByaXZdKGtleSkucHJpdl9wcm9wID0gMjAwO1xcclxcbiAgICB9O1xcclxcbiAgICBDaGlsZENsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXFxyXFxuICAgICAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGVcXHJcXG4gICAgKTtcXHJcXG4gICAgQ2hpbGRDbGFzcy5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2codGhpc1twcml2XShrZXkpLnByaXZfcHJvcCk7XFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiBDaGlsZENsYXNzO1xcclxcbn0oKTtcXHJcXG5cXHJcXG52YXIgaW5zdGFuY2UgPSBuZXcgQ2hpbGRDbGFzcygpO1xcclxcbmluc3RhbmNlLnRlc3QoKTsgLy8gYDIwMGAgbG9nZ2VkLCBhcyBleHBlY3RlZFxcclxcbmluc3RhbmNlLnBhcmVudF90ZXN0KCk7IC8vIGAxMDBgIGxvZ2dlZCwgYXMgZXhwZWN0ZWRcXHJcXG5cXHJcXG4vLyBZZXQsIHRoZXJlJ3Mgbm8gd2F5IHRvIGFjY2VzcyB0aGUgcHJvcGVydHkgZnJvbSBvdXRzaWRlIG9mIHRoZSBjbG9zdXJlXFxyXFxuYGBgXFxyXFxuXFxyXFxuUHJldHR5IG11Y2ggdGhlIG9ubHkgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcmV2aW91cyBjb2RlIHNuaXBwZXQgaXMgdGhhdCB3ZSByZXBsYWNlZCBgdGhpcy5fYCBmb3IgYm90aCBjaGlsZCBhbmQgcGFyZW50IGNsYXNzZXMgd2l0aCBgdGhpc1twcml2XWAsIHdoZXJlIGBwcml2YCBpcyBuYW1lc3BhY2VkIGFuZCByYW5kb21seSBnZW5lcmF0ZWQgdG8gZW5zdXJlIHRoYXQgcHJpdmF0ZSBhY2Nlc3MgZnVuY3Rpb24gaXMgc3RvcmVkIHVuZGVyIGEgZGlmZmVyZW50IHByb3BlcnR5IG5hbWUgZm9yIGNoaWxkIGFuZCBwYXJlbnQuXFxyXFxuXFxyXFxuQW5vdGhlciByZWNvbW1lbmRhdGlvbiBJIGNhbiBtYWtlIGlzIHRoYXQgeW91IHNob3VsZCBwcm9iYWJseSBzZWN1cmUgYHRoaXNbcHJpdl1gIGJ5IG1ha2luZyBpdCBub24tY29uZmlndXJhYmxlLCBub24tZW51bWVyYWJsZSBhbmQgcmVhZC1vbmx5OlxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJpdiwge1xcclxcbiAgICB2YWx1ZTogcHJpdmF0ZShrZXkpXFxyXFxufSlcXHJcXG5gYGBcXHJcXG5cXHJcXG5JbnN0ZWFkIG9mIGp1c3RcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxudGhpc1twcml2XSA9IHByaXZhdGUoa2V5KVxcclxcbmBgYFxcclxcblxcclxcblRoaXMgd2lsbCBtYWtlIHN1cmUgdGhhdCB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gcmVtb3ZlIG9yIG1vZGlmeSBgdGhpc1twcml2XWAsIHdoaWNoIGlzIGNydWNpYWwgZm9yIGNvcnJlY3QgcHJpdmF0ZSBzdG9yYWdlIGZ1bmN0aW9uaW5nLlxcclxcblxcclxcbiMjIENvbmNsdXNpb25cXHJcXG5cXHJcXG5HbyBhaGVhZCBhbmQgdXNlICoqYWNjZXNzb3IgcGF0dGVybioqISBJdCBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0cnVseSBlbmNhcHN1bGF0ZWQgcHJvcGVydGllcyBhbmQgdXNlIHRoZW0gb24gYSBwcm90b3R5cGUuIExldCBvdGhlcnMga25vdyBhYm91dCB0aGlzIG1ldGhvZCBzbyB3ZSBkb24ndCBjb250aW51ZSB0aGUgbWlzY29uY2VwdGlvbiB0aGF0IHByaXZhY3kgaXMgaW1wb3NzaWJsZSB0byBhY2hpZXZlIGluIEphdmFTY3JpcHQuIFNoYXJpbmcgdGhpcyBhcnRpY2xlIHdpbGwgYWxzbyBoZWxwICoq8J+YiioqXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==