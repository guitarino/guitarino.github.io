(self.webpackChunkguitarino_github_io=self.webpackChunkguitarino_github_io||[]).push([[361],{2428:(e,r,t)=>{"use strict";t.d(r,{Z:()=>l});var n=t(3517),a=t.n(n),s=t(9306),o=t(3594),i=t(6635),p=t(4870),c=t(6777);function l(e){return(0,s.h)(o.Z,a()({},e,{class:"Markdown ".concat(e.class||""),options:{overrides:{a:i.Z,pre:s.HY,code:function(e){var r=e.class&&e.class.replace(/^lang-/,"");return r?(0,s.h)(p.Z,a()({},e,{language:r,style:c.Z})):(0,s.h)("code",e)}}}}))}},7361:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>i,menu:()=>o,title:()=>s});var n=t(2428),a=t(9306),s="You Can Create Private Properties In JS - Kirill Shestakov",o="blog";function i(e){return(0,a.h)(n.Z,{class:"AccessorPattern ".concat(e.class||"")},"# You Can Create Private Properties In JS\r\n\r\n**Note: this article was written a while ago and has since been archived, because it's no longer relevant. Nowadays, there's more proper ways of creating private properties using the hash symbol, and there's also a possibility of using TypeScript, which has compile time private properties. I'm keeping this article for history sake.**\r\n\r\nIt's very [common](https://stackoverflow.com/questions/436120/javascript-accessing-private-member-variables-from-prototype-defined-functions/436147#436147) for JavaScript developers to claim that it's impossible to create truly encapsulated properties and methods on an object **and use them on its prototype**.\r\n\r\nIn ES6, there are a few ways of easily achieving private properties without memory leaks. For example, you could use a ES6 **Symbol**:\r\n\r\n```javascript\r\n// Closure\r\nvar SomeClass = function() {\r\n    var priv_prop = Symbol();\r\n    var SomeClass = function() {\r\n        this[priv_prop] = 200;\r\n    };\r\n    SomeClass.prototype.test = function() {\r\n        console.log(this[priv_prop]);\r\n    };\r\n    return SomeClass;\r\n}();\r\nvar instance = new SomeClass();\r\ninstance.test(); // `200` logged\r\n```\r\n\r\nAlternatively, you could use a **WeakMap**:\r\n\r\n```javascript\r\n// Closure\r\nvar SomeClass = function() {\r\n    var priv_prop1 = new WeakMap();\r\n    var priv_prop2 = new WeakMap();\r\n    var SomeClass = function() {\r\n        priv_prop1.set(this, 100);\r\n        priv_prop2.set(this, 200);\r\n    };\r\n    SomeClass.prototype.test = function() {\r\n        console.log(priv_prop1.get(this));\r\n        console.log(priv_prop2.get(this));\r\n    };\r\n    return SomeClass;\r\n}();\r\nvar instance = new SomeClass();\r\ninstance.test(); // `100` and `200` logged\r\n```\r\n\r\nThe problem with the **Symbol** method is that you can still access those properties using `Object.getOwnPropertySymbols`. In either case, you would likely have to include bulky polyfills in production code.\r\n\r\nPrior to ES6, there was no *obvious* way to create private properties usable on prototype. The claim is that you either have to abandon the idea or use a memory leaky **Map** (alternatively, you could use 2 arrays). But what if I told you that there is actually a way to do this that is cross-browser, needs no polyfills or ES6, and doesn't produce memory leaks?\r\n\r\n## The idea\r\n\r\nI haven't seen this method used by anyone (**EDIT**: it was pointed out to me that I wasn't the first one to come up with this method. **[Read more here](https://medium.com/front-end-hacking/achieving-complete-data-encapsulation-in-javascript-5454a6b7410b)**), so I'd like to call it an **accessor pattern**. The idea is to create a *closure*, create a *key* inside the closure and create a *storage for private properties* that can only be accessed if the correct key is provided. Here's how you would implement it:\r\n\r\n```javascript\r\n/* Here's how you can create truly private\r\n   properties in JS and use them on prototype */\r\n\r\n// Closure\r\nvar SomeClass = function() {\r\n    var key = {};\r\n\r\n    var private = function() {\r\n        var obj = {};\r\n        return function(testkey) {\r\n            if(key === testkey) return obj;\r\n            // If the user of the class tries to access private\r\n            // properties, they won't have the access to the `key`\r\n            console.error('Cannot access private properties');\r\n            return undefined;\r\n        };\r\n    };\r\n\r\n    var SomeClass = function() {\r\n        this._ = private(); // Creates a private object\r\n        this._(key).priv_prop = 200; // this._(key) will return the private object\r\n    };\r\n\r\n    SomeClass.prototype.test = function() {\r\n        console.log(this._(key).priv_prop); // Using property from prototype\r\n    };\r\n\r\n    return SomeClass;\r\n}();\r\n\r\nvar instance = new SomeClass();\r\ninstance.test(); // `200` logged\r\n\r\nvar wrong_key = {};\r\ninstance._(wrong_key); // undefined; error logged\r\n```\r\n\r\nPretty simple, huh? `private` function creates the *private storage* and returns a private access function that will only return the *storage* if the correct *key* is provided. Then, in constructor, we assign this private access function to `this._` which can be easily used on the prototype, provided that the prototype properties also have access to the *key*. Basically, there is no way to access the *private storage* without having the correct *key*. Hence, if the user tries to call `this._` with any argument, maybe with a `wrong_key`, then the attempt will fail, error will be logged, and all the user will get is undefined.\r\n\r\nAdvantages of this method:\r\n\r\n* It's quite simple. All you need is to create a *private storage*, and you can access all private properties inline within a constructor / prototype.\r\n* It lets you create truly private properties that can be accessed from the prototype. The user of the class will not be able to access them.\r\n\r\nDisadvantage of this method:\r\n\r\n* It slightly pollutes the namespace, because you have to assign the private storage to `this._` or alike, but there's probably no other way to do this.\r\n\r\n## A problem\r\n\r\nA minor problem with this method is that, in case of prototypal inheritance, if both child and parent use the same property name for the private access function (in this example, `this._`), then the parent's private properties cannot be accessed within parent's prototype, because `this._` will refer to child's private access function. Here's what I mean,\r\n\r\n```javascript\r\n// Note: this Gist is to show a problem with accessor pattern\r\n// and inheritance. Do not use!\r\n\r\nvar private = function(key) {\r\n    var obj = {};\r\n    return function(testkey) {\r\n        if(key === testkey) return obj;\r\n        console.error('Cannot access private properties');\r\n        return undefined;\r\n    };\r\n};\r\n\r\nvar ParentClass = function() {\r\n    var key = {};\r\n    var ParentClass = function() {\r\n        this._ = private(key);\r\n        this._(key).priv_prop = 100;\r\n    };\r\n    ParentClass.prototype.parent_test = function() {\r\n        console.log(this._(key).priv_prop);\r\n    };\r\n    return ParentClass;\r\n}();\r\n\r\nvar ChildClass = function() {\r\n    var key = {};\r\n    var ChildClass = function() {\r\n        ParentClass.call(this);\r\n        this._ = private(key);\r\n        this._(key).priv_prop = 200;\r\n    };\r\n    ChildClass.prototype = Object.create(\r\n        ParentClass.prototype\r\n    );\r\n    ChildClass.prototype.test = function() {\r\n        console.log(this._(key).priv_prop);\r\n    };\r\n    return ChildClass;\r\n}();\r\n\r\nvar instance = new ChildClass();\r\ninstance.test(); // `200` is correctly logged\r\ninstance.parent_test(); // ERROR! (expected result: `100`)\r\n```\r\n\r\nWhen `instance.parent_test` is called, `this._` inside it will refer to the child's private access function, hence, the `key` will mismatch and the error will be logged. However, this problem can be quite easily solved.\r\n\r\n## The final solution\r\n\r\nThe best solution is to namespace and make sure that parent and child have different property names for their private access functions. Here's the final solution:\r\n\r\n```javascript\r\n/* Here's how you can create truly private\r\n   properties in JS and use them on prototype */\r\n\r\n// Creates private storage, secures with a key, and\r\n// returns a private access function\r\nvar private = function(key) {\r\n    var obj = {};\r\n    return function(testkey) {\r\n        if(key === testkey) return obj;\r\n        console.error('Cannot access private properties');\r\n        return undefined;\r\n    };\r\n};\r\n\r\n// Create closure\r\nvar ParentClass = function() {\r\n    var priv = '_ParentClass' + Math.random(); // Namespace\r\n    var key = {}; // Create key withing closure\r\n    var ParentClass = function() {\r\n        this[priv] = private(key); // Create private storage\r\n        this[priv](key).priv_prop = 100; // Modify any private data\r\n    };\r\n    ParentClass.prototype.parent_test = function() {\r\n        console.log(this[priv](key).priv_prop); // Access private data\r\n    };\r\n    return ParentClass;\r\n}();\r\n\r\nvar ChildClass = function() {\r\n    var priv = '_ChildClass' + Math.random();\r\n    var key = {};\r\n    var ChildClass = function() {\r\n        ParentClass.call(this);\r\n        this[priv] = private(key);\r\n        this[priv](key).priv_prop = 200;\r\n    };\r\n    ChildClass.prototype = Object.create(\r\n        ParentClass.prototype\r\n    );\r\n    ChildClass.prototype.test = function() {\r\n        console.log(this[priv](key).priv_prop);\r\n    };\r\n    return ChildClass;\r\n}();\r\n\r\nvar instance = new ChildClass();\r\ninstance.test(); // `200` logged, as expected\r\ninstance.parent_test(); // `100` logged, as expected\r\n\r\n// Yet, there's no way to access the property from outside of the closure\r\n```\r\n\r\nPretty much the only difference from the previous code snippet is that we replaced `this._` for both child and parent classes with `this[priv]`, where `priv` is namespaced and randomly generated to ensure that private access function is stored under a different property name for child and parent.\r\n\r\nAnother recommendation I can make is that you should probably secure `this[priv]` by making it non-configurable, non-enumerable and read-only:\r\n\r\n```javascript\r\nObject.defineProperty(this, priv, {\r\n    value: private(key)\r\n})\r\n```\r\n\r\nInstead of just\r\n\r\n```javascript\r\nthis[priv] = private(key)\r\n```\r\n\r\nThis will make sure that user will not be able to remove or modify `this[priv]`, which is crucial for correct private storage functioning.\r\n\r\n## Conclusion\r\n\r\nGo ahead and use **accessor pattern**! It allows you to create truly encapsulated properties and use them on a prototype. Let others know about this method so we don't continue the misconception that privacy is impossible to achieve in JavaScript. Sharing this article will also help **ðŸ˜Š**")}}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndWl0YXJpbm8uZ2l0aHViLmlvLy4vc3JjL2NvbXBvbmVudHMvTWFya2Rvd24udHN4Iiwid2VicGFjazovL2d1aXRhcmluby5naXRodWIuaW8vLi9zcmMvcGFnZXMvQWNjZXNzb3JQYXR0ZXJuLnRzeCIsIndlYnBhY2s6Ly9ndWl0YXJpbm8uZ2l0aHViLmlvLy4vY29udGVudC9BY2Nlc3NvclBhdHRlcm4ubWQiXSwibmFtZXMiOlsiTWFya2Rvd24iLCJwcm9wcyIsImNsYXNzIiwib3B0aW9ucyIsIm92ZXJyaWRlcyIsImEiLCJMaW5rIiwicHJlIiwiRnJhZ21lbnQiLCJjb2RlIiwibGFuZ3VhZ2UiLCJyZXBsYWNlIiwic3R5bGUiLCJtb25va2FpU3VibGltZSIsInRpdGxlIiwibWVudSIsIkFjY2Vzc29yUGF0dGVybiJdLCJtYXBwaW5ncyI6Im1OQU1lLFNBQVNBLEVBQVNDLEdBQ2hDLE9BQU8sT0FBQyxJQUFELE9BQXFCQSxFQUFyQixDQUE0QkMsTUFBQSxtQkFBbUJELEVBQUssT0FBTCxJQUFxQkUsUUFBUyxDQUNuRkMsVUFBVyxDQUNWQyxFQUFHQyxJQUNIQyxJQUFLQyxLQUNMQyxLQUFNLFNBQUFSLEdBQ0wsSUFBTVMsRUFBV1QsRUFBSyxPQUFVQSxFQUFLLE1BQU9VLFFBQVEsU0FBVSxJQUM5RCxPQUFJRCxHQUNJLE9BQUMsSUFBRCxPQUNGVCxFQURFLENBRU5TLFNBQVVBLEVBQ1ZFLE1BQU9DLFFBSUQsY0FBVVosVyx5R0NqQlRhLEVBQVEsNkRBRVJDLEVBQU8sT0FFTCxTQUFTQyxFQUFnQmYsR0FDdkMsT0FBTyxPQUFDRCxFQUFBLEVBQUQsQ0FBVUUsTUFBQSwwQkFBMEJELEVBQUssT0FBTCxLQ1Q1QyIsImZpbGUiOiIzNjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGcmFnbWVudCwgaCB9IGZyb20gJ3ByZWFjdCc7XHJcbmltcG9ydCBNYXJrZG93bkxpYnJhcnkgZnJvbSAnbWFya2Rvd24tdG8tanN4JztcclxuaW1wb3J0IExpbmsgZnJvbSAnQGNvbXBvbmVudHMvTGluayc7XHJcbmltcG9ydCBTeW50YXhIaWdobGlnaHRlciBmcm9tICdyZWFjdC1zeW50YXgtaGlnaGxpZ2h0ZXInO1xyXG5pbXBvcnQgeyBtb25va2FpU3VibGltZSB9IGZyb20gJ3JlYWN0LXN5bnRheC1oaWdobGlnaHRlci9kaXN0L2VzbS9zdHlsZXMvaGxqcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXJrZG93bihwcm9wczogYW55KSB7XHJcblx0cmV0dXJuIDxNYXJrZG93bkxpYnJhcnkgey4uLnByb3BzfSBjbGFzcz17YE1hcmtkb3duICR7cHJvcHMuY2xhc3MgfHwgYGB9YH0gb3B0aW9ucz17e1xyXG5cdFx0b3ZlcnJpZGVzOiB7XHJcblx0XHRcdGE6IExpbmssXHJcblx0XHRcdHByZTogRnJhZ21lbnQsXHJcblx0XHRcdGNvZGU6IHByb3BzID0+IHtcclxuXHRcdFx0XHRjb25zdCBsYW5ndWFnZSA9IHByb3BzLmNsYXNzICYmIHByb3BzLmNsYXNzLnJlcGxhY2UoL15sYW5nLS8sICcnKTtcclxuXHRcdFx0XHRpZiAobGFuZ3VhZ2UpIHtcclxuXHRcdFx0XHRcdHJldHVybiA8U3ludGF4SGlnaGxpZ2h0ZXJcclxuXHRcdFx0XHRcdFx0ey4uLnByb3BzfVxyXG5cdFx0XHRcdFx0XHRsYW5ndWFnZT17bGFuZ3VhZ2V9XHJcblx0XHRcdFx0XHRcdHN0eWxlPXttb25va2FpU3VibGltZX1cclxuXHRcdFx0XHRcdC8+O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiA8Y29kZSB7Li4ucHJvcHN9IC8+O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdH0sXHJcblx0fX0gLz47XHJcbn0iLCJpbXBvcnQgTWFya2Rvd24gZnJvbSAnQGNvbXBvbmVudHMvTWFya2Rvd24nO1xyXG5pbXBvcnQgeyBoIH0gZnJvbSAncHJlYWN0JztcclxuaW1wb3J0IGNvbnRlbnQgZnJvbSAnQGNvbnRlbnQvQWNjZXNzb3JQYXR0ZXJuLm1kJztcclxuXHJcbmV4cG9ydCBjb25zdCB0aXRsZSA9ICdZb3UgQ2FuIENyZWF0ZSBQcml2YXRlIFByb3BlcnRpZXMgSW4gSlMgLSBLaXJpbGwgU2hlc3Rha292JztcclxuXHJcbmV4cG9ydCBjb25zdCBtZW51ID0gJ2Jsb2cnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWNjZXNzb3JQYXR0ZXJuKHByb3BzOiB7IGNsYXNzPzogc3RyaW5nIH0pIHtcclxuXHRyZXR1cm4gPE1hcmtkb3duIGNsYXNzPXtgQWNjZXNzb3JQYXR0ZXJuICR7cHJvcHMuY2xhc3MgfHwgYGB9YH0+XHJcblx0XHR7Y29udGVudH1cclxuXHQ8L01hcmtkb3duPjtcclxufSIsImV4cG9ydCBkZWZhdWx0IFwiIyBZb3UgQ2FuIENyZWF0ZSBQcml2YXRlIFByb3BlcnRpZXMgSW4gSlNcXHJcXG5cXHJcXG4qKk5vdGU6IHRoaXMgYXJ0aWNsZSB3YXMgd3JpdHRlbiBhIHdoaWxlIGFnbyBhbmQgaGFzIHNpbmNlIGJlZW4gYXJjaGl2ZWQsIGJlY2F1c2UgaXQncyBubyBsb25nZXIgcmVsZXZhbnQuIE5vd2FkYXlzLCB0aGVyZSdzIG1vcmUgcHJvcGVyIHdheXMgb2YgY3JlYXRpbmcgcHJpdmF0ZSBwcm9wZXJ0aWVzIHVzaW5nIHRoZSBoYXNoIHN5bWJvbCwgYW5kIHRoZXJlJ3MgYWxzbyBhIHBvc3NpYmlsaXR5IG9mIHVzaW5nIFR5cGVTY3JpcHQsIHdoaWNoIGhhcyBjb21waWxlIHRpbWUgcHJpdmF0ZSBwcm9wZXJ0aWVzLiBJJ20ga2VlcGluZyB0aGlzIGFydGljbGUgZm9yIGhpc3Rvcnkgc2FrZS4qKlxcclxcblxcclxcbkl0J3MgdmVyeSBbY29tbW9uXShodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MzYxMjAvamF2YXNjcmlwdC1hY2Nlc3NpbmctcHJpdmF0ZS1tZW1iZXItdmFyaWFibGVzLWZyb20tcHJvdG90eXBlLWRlZmluZWQtZnVuY3Rpb25zLzQzNjE0NyM0MzYxNDcpIGZvciBKYXZhU2NyaXB0IGRldmVsb3BlcnMgdG8gY2xhaW0gdGhhdCBpdCdzIGltcG9zc2libGUgdG8gY3JlYXRlIHRydWx5IGVuY2Fwc3VsYXRlZCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9uIGFuIG9iamVjdCAqKmFuZCB1c2UgdGhlbSBvbiBpdHMgcHJvdG90eXBlKiouXFxyXFxuXFxyXFxuSW4gRVM2LCB0aGVyZSBhcmUgYSBmZXcgd2F5cyBvZiBlYXNpbHkgYWNoaWV2aW5nIHByaXZhdGUgcHJvcGVydGllcyB3aXRob3V0IG1lbW9yeSBsZWFrcy4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCB1c2UgYSBFUzYgKipTeW1ib2wqKjpcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gQ2xvc3VyZVxcclxcbnZhciBTb21lQ2xhc3MgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgdmFyIHByaXZfcHJvcCA9IFN5bWJvbCgpO1xcclxcbiAgICB2YXIgU29tZUNsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICB0aGlzW3ByaXZfcHJvcF0gPSAyMDA7XFxyXFxuICAgIH07XFxyXFxuICAgIFNvbWVDbGFzcy5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2codGhpc1twcml2X3Byb3BdKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgcmV0dXJuIFNvbWVDbGFzcztcXHJcXG59KCk7XFxyXFxudmFyIGluc3RhbmNlID0gbmV3IFNvbWVDbGFzcygpO1xcclxcbmluc3RhbmNlLnRlc3QoKTsgLy8gYDIwMGAgbG9nZ2VkXFxyXFxuYGBgXFxyXFxuXFxyXFxuQWx0ZXJuYXRpdmVseSwgeW91IGNvdWxkIHVzZSBhICoqV2Vha01hcCoqOlxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG4vLyBDbG9zdXJlXFxyXFxudmFyIFNvbWVDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICB2YXIgcHJpdl9wcm9wMSA9IG5ldyBXZWFrTWFwKCk7XFxyXFxuICAgIHZhciBwcml2X3Byb3AyID0gbmV3IFdlYWtNYXAoKTtcXHJcXG4gICAgdmFyIFNvbWVDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgcHJpdl9wcm9wMS5zZXQodGhpcywgMTAwKTtcXHJcXG4gICAgICAgIHByaXZfcHJvcDIuc2V0KHRoaXMsIDIwMCk7XFxyXFxuICAgIH07XFxyXFxuICAgIFNvbWVDbGFzcy5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2cocHJpdl9wcm9wMS5nZXQodGhpcykpO1xcclxcbiAgICAgICAgY29uc29sZS5sb2cocHJpdl9wcm9wMi5nZXQodGhpcykpO1xcclxcbiAgICB9O1xcclxcbiAgICByZXR1cm4gU29tZUNsYXNzO1xcclxcbn0oKTtcXHJcXG52YXIgaW5zdGFuY2UgPSBuZXcgU29tZUNsYXNzKCk7XFxyXFxuaW5zdGFuY2UudGVzdCgpOyAvLyBgMTAwYCBhbmQgYDIwMGAgbG9nZ2VkXFxyXFxuYGBgXFxyXFxuXFxyXFxuVGhlIHByb2JsZW0gd2l0aCB0aGUgKipTeW1ib2wqKiBtZXRob2QgaXMgdGhhdCB5b3UgY2FuIHN0aWxsIGFjY2VzcyB0aG9zZSBwcm9wZXJ0aWVzIHVzaW5nIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYC4gSW4gZWl0aGVyIGNhc2UsIHlvdSB3b3VsZCBsaWtlbHkgaGF2ZSB0byBpbmNsdWRlIGJ1bGt5IHBvbHlmaWxscyBpbiBwcm9kdWN0aW9uIGNvZGUuXFxyXFxuXFxyXFxuUHJpb3IgdG8gRVM2LCB0aGVyZSB3YXMgbm8gKm9idmlvdXMqIHdheSB0byBjcmVhdGUgcHJpdmF0ZSBwcm9wZXJ0aWVzIHVzYWJsZSBvbiBwcm90b3R5cGUuIFRoZSBjbGFpbSBpcyB0aGF0IHlvdSBlaXRoZXIgaGF2ZSB0byBhYmFuZG9uIHRoZSBpZGVhIG9yIHVzZSBhIG1lbW9yeSBsZWFreSAqKk1hcCoqIChhbHRlcm5hdGl2ZWx5LCB5b3UgY291bGQgdXNlIDIgYXJyYXlzKS4gQnV0IHdoYXQgaWYgSSB0b2xkIHlvdSB0aGF0IHRoZXJlIGlzIGFjdHVhbGx5IGEgd2F5IHRvIGRvIHRoaXMgdGhhdCBpcyBjcm9zcy1icm93c2VyLCBuZWVkcyBubyBwb2x5ZmlsbHMgb3IgRVM2LCBhbmQgZG9lc24ndCBwcm9kdWNlIG1lbW9yeSBsZWFrcz9cXHJcXG5cXHJcXG4jIyBUaGUgaWRlYVxcclxcblxcclxcbkkgaGF2ZW4ndCBzZWVuIHRoaXMgbWV0aG9kIHVzZWQgYnkgYW55b25lICgqKkVESVQqKjogaXQgd2FzIHBvaW50ZWQgb3V0IHRvIG1lIHRoYXQgSSB3YXNuJ3QgdGhlIGZpcnN0IG9uZSB0byBjb21lIHVwIHdpdGggdGhpcyBtZXRob2QuICoqW1JlYWQgbW9yZSBoZXJlXShodHRwczovL21lZGl1bS5jb20vZnJvbnQtZW5kLWhhY2tpbmcvYWNoaWV2aW5nLWNvbXBsZXRlLWRhdGEtZW5jYXBzdWxhdGlvbi1pbi1qYXZhc2NyaXB0LTU0NTRhNmI3NDEwYikqKiksIHNvIEknZCBsaWtlIHRvIGNhbGwgaXQgYW4gKiphY2Nlc3NvciBwYXR0ZXJuKiouIFRoZSBpZGVhIGlzIHRvIGNyZWF0ZSBhICpjbG9zdXJlKiwgY3JlYXRlIGEgKmtleSogaW5zaWRlIHRoZSBjbG9zdXJlIGFuZCBjcmVhdGUgYSAqc3RvcmFnZSBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzKiB0aGF0IGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGlmIHRoZSBjb3JyZWN0IGtleSBpcyBwcm92aWRlZC4gSGVyZSdzIGhvdyB5b3Ugd291bGQgaW1wbGVtZW50IGl0OlxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG4vKiBIZXJlJ3MgaG93IHlvdSBjYW4gY3JlYXRlIHRydWx5IHByaXZhdGVcXHJcXG4gICBwcm9wZXJ0aWVzIGluIEpTIGFuZCB1c2UgdGhlbSBvbiBwcm90b3R5cGUgKi9cXHJcXG5cXHJcXG4vLyBDbG9zdXJlXFxyXFxudmFyIFNvbWVDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICB2YXIga2V5ID0ge307XFxyXFxuXFxyXFxuICAgIHZhciBwcml2YXRlID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICB2YXIgb2JqID0ge307XFxyXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGVzdGtleSkge1xcclxcbiAgICAgICAgICAgIGlmKGtleSA9PT0gdGVzdGtleSkgcmV0dXJuIG9iajtcXHJcXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBvZiB0aGUgY2xhc3MgdHJpZXMgdG8gYWNjZXNzIHByaXZhdGVcXHJcXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzLCB0aGV5IHdvbid0IGhhdmUgdGhlIGFjY2VzcyB0byB0aGUgYGtleWBcXHJcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgYWNjZXNzIHByaXZhdGUgcHJvcGVydGllcycpO1xcclxcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxyXFxuICAgICAgICB9O1xcclxcbiAgICB9O1xcclxcblxcclxcbiAgICB2YXIgU29tZUNsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICB0aGlzLl8gPSBwcml2YXRlKCk7IC8vIENyZWF0ZXMgYSBwcml2YXRlIG9iamVjdFxcclxcbiAgICAgICAgdGhpcy5fKGtleSkucHJpdl9wcm9wID0gMjAwOyAvLyB0aGlzLl8oa2V5KSB3aWxsIHJldHVybiB0aGUgcHJpdmF0ZSBvYmplY3RcXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgU29tZUNsYXNzLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLl8oa2V5KS5wcml2X3Byb3ApOyAvLyBVc2luZyBwcm9wZXJ0eSBmcm9tIHByb3RvdHlwZVxcclxcbiAgICB9O1xcclxcblxcclxcbiAgICByZXR1cm4gU29tZUNsYXNzO1xcclxcbn0oKTtcXHJcXG5cXHJcXG52YXIgaW5zdGFuY2UgPSBuZXcgU29tZUNsYXNzKCk7XFxyXFxuaW5zdGFuY2UudGVzdCgpOyAvLyBgMjAwYCBsb2dnZWRcXHJcXG5cXHJcXG52YXIgd3Jvbmdfa2V5ID0ge307XFxyXFxuaW5zdGFuY2UuXyh3cm9uZ19rZXkpOyAvLyB1bmRlZmluZWQ7IGVycm9yIGxvZ2dlZFxcclxcbmBgYFxcclxcblxcclxcblByZXR0eSBzaW1wbGUsIGh1aD8gYHByaXZhdGVgIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlICpwcml2YXRlIHN0b3JhZ2UqIGFuZCByZXR1cm5zIGEgcHJpdmF0ZSBhY2Nlc3MgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgcmV0dXJuIHRoZSAqc3RvcmFnZSogaWYgdGhlIGNvcnJlY3QgKmtleSogaXMgcHJvdmlkZWQuIFRoZW4sIGluIGNvbnN0cnVjdG9yLCB3ZSBhc3NpZ24gdGhpcyBwcml2YXRlIGFjY2VzcyBmdW5jdGlvbiB0byBgdGhpcy5fYCB3aGljaCBjYW4gYmUgZWFzaWx5IHVzZWQgb24gdGhlIHByb3RvdHlwZSwgcHJvdmlkZWQgdGhhdCB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGUgKmtleSouIEJhc2ljYWxseSwgdGhlcmUgaXMgbm8gd2F5IHRvIGFjY2VzcyB0aGUgKnByaXZhdGUgc3RvcmFnZSogd2l0aG91dCBoYXZpbmcgdGhlIGNvcnJlY3QgKmtleSouIEhlbmNlLCBpZiB0aGUgdXNlciB0cmllcyB0byBjYWxsIGB0aGlzLl9gIHdpdGggYW55IGFyZ3VtZW50LCBtYXliZSB3aXRoIGEgYHdyb25nX2tleWAsIHRoZW4gdGhlIGF0dGVtcHQgd2lsbCBmYWlsLCBlcnJvciB3aWxsIGJlIGxvZ2dlZCwgYW5kIGFsbCB0aGUgdXNlciB3aWxsIGdldCBpcyB1bmRlZmluZWQuXFxyXFxuXFxyXFxuQWR2YW50YWdlcyBvZiB0aGlzIG1ldGhvZDpcXHJcXG5cXHJcXG4qIEl0J3MgcXVpdGUgc2ltcGxlLiBBbGwgeW91IG5lZWQgaXMgdG8gY3JlYXRlIGEgKnByaXZhdGUgc3RvcmFnZSosIGFuZCB5b3UgY2FuIGFjY2VzcyBhbGwgcHJpdmF0ZSBwcm9wZXJ0aWVzIGlubGluZSB3aXRoaW4gYSBjb25zdHJ1Y3RvciAvIHByb3RvdHlwZS5cXHJcXG4qIEl0IGxldHMgeW91IGNyZWF0ZSB0cnVseSBwcml2YXRlIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgYWNjZXNzZWQgZnJvbSB0aGUgcHJvdG90eXBlLiBUaGUgdXNlciBvZiB0aGUgY2xhc3Mgd2lsbCBub3QgYmUgYWJsZSB0byBhY2Nlc3MgdGhlbS5cXHJcXG5cXHJcXG5EaXNhZHZhbnRhZ2Ugb2YgdGhpcyBtZXRob2Q6XFxyXFxuXFxyXFxuKiBJdCBzbGlnaHRseSBwb2xsdXRlcyB0aGUgbmFtZXNwYWNlLCBiZWNhdXNlIHlvdSBoYXZlIHRvIGFzc2lnbiB0aGUgcHJpdmF0ZSBzdG9yYWdlIHRvIGB0aGlzLl9gIG9yIGFsaWtlLCBidXQgdGhlcmUncyBwcm9iYWJseSBubyBvdGhlciB3YXkgdG8gZG8gdGhpcy5cXHJcXG5cXHJcXG4jIyBBIHByb2JsZW1cXHJcXG5cXHJcXG5BIG1pbm9yIHByb2JsZW0gd2l0aCB0aGlzIG1ldGhvZCBpcyB0aGF0LCBpbiBjYXNlIG9mIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIGlmIGJvdGggY2hpbGQgYW5kIHBhcmVudCB1c2UgdGhlIHNhbWUgcHJvcGVydHkgbmFtZSBmb3IgdGhlIHByaXZhdGUgYWNjZXNzIGZ1bmN0aW9uIChpbiB0aGlzIGV4YW1wbGUsIGB0aGlzLl9gKSwgdGhlbiB0aGUgcGFyZW50J3MgcHJpdmF0ZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBhY2Nlc3NlZCB3aXRoaW4gcGFyZW50J3MgcHJvdG90eXBlLCBiZWNhdXNlIGB0aGlzLl9gIHdpbGwgcmVmZXIgdG8gY2hpbGQncyBwcml2YXRlIGFjY2VzcyBmdW5jdGlvbi4gSGVyZSdzIHdoYXQgSSBtZWFuLFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG4vLyBOb3RlOiB0aGlzIEdpc3QgaXMgdG8gc2hvdyBhIHByb2JsZW0gd2l0aCBhY2Nlc3NvciBwYXR0ZXJuXFxyXFxuLy8gYW5kIGluaGVyaXRhbmNlLiBEbyBub3QgdXNlIVxcclxcblxcclxcbnZhciBwcml2YXRlID0gZnVuY3Rpb24oa2V5KSB7XFxyXFxuICAgIHZhciBvYmogPSB7fTtcXHJcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRlc3RrZXkpIHtcXHJcXG4gICAgICAgIGlmKGtleSA9PT0gdGVzdGtleSkgcmV0dXJuIG9iajtcXHJcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBhY2Nlc3MgcHJpdmF0ZSBwcm9wZXJ0aWVzJyk7XFxyXFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcclxcbiAgICB9O1xcclxcbn07XFxyXFxuXFxyXFxudmFyIFBhcmVudENsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgIHZhciBrZXkgPSB7fTtcXHJcXG4gICAgdmFyIFBhcmVudENsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICB0aGlzLl8gPSBwcml2YXRlKGtleSk7XFxyXFxuICAgICAgICB0aGlzLl8oa2V5KS5wcml2X3Byb3AgPSAxMDA7XFxyXFxuICAgIH07XFxyXFxuICAgIFBhcmVudENsYXNzLnByb3RvdHlwZS5wYXJlbnRfdGVzdCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5fKGtleSkucHJpdl9wcm9wKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgcmV0dXJuIFBhcmVudENsYXNzO1xcclxcbn0oKTtcXHJcXG5cXHJcXG52YXIgQ2hpbGRDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICB2YXIga2V5ID0ge307XFxyXFxuICAgIHZhciBDaGlsZENsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICBQYXJlbnRDbGFzcy5jYWxsKHRoaXMpO1xcclxcbiAgICAgICAgdGhpcy5fID0gcHJpdmF0ZShrZXkpO1xcclxcbiAgICAgICAgdGhpcy5fKGtleSkucHJpdl9wcm9wID0gMjAwO1xcclxcbiAgICB9O1xcclxcbiAgICBDaGlsZENsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXFxyXFxuICAgICAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGVcXHJcXG4gICAgKTtcXHJcXG4gICAgQ2hpbGRDbGFzcy5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5fKGtleSkucHJpdl9wcm9wKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgcmV0dXJuIENoaWxkQ2xhc3M7XFxyXFxufSgpO1xcclxcblxcclxcbnZhciBpbnN0YW5jZSA9IG5ldyBDaGlsZENsYXNzKCk7XFxyXFxuaW5zdGFuY2UudGVzdCgpOyAvLyBgMjAwYCBpcyBjb3JyZWN0bHkgbG9nZ2VkXFxyXFxuaW5zdGFuY2UucGFyZW50X3Rlc3QoKTsgLy8gRVJST1IhIChleHBlY3RlZCByZXN1bHQ6IGAxMDBgKVxcclxcbmBgYFxcclxcblxcclxcbldoZW4gYGluc3RhbmNlLnBhcmVudF90ZXN0YCBpcyBjYWxsZWQsIGB0aGlzLl9gIGluc2lkZSBpdCB3aWxsIHJlZmVyIHRvIHRoZSBjaGlsZCdzIHByaXZhdGUgYWNjZXNzIGZ1bmN0aW9uLCBoZW5jZSwgdGhlIGBrZXlgIHdpbGwgbWlzbWF0Y2ggYW5kIHRoZSBlcnJvciB3aWxsIGJlIGxvZ2dlZC4gSG93ZXZlciwgdGhpcyBwcm9ibGVtIGNhbiBiZSBxdWl0ZSBlYXNpbHkgc29sdmVkLlxcclxcblxcclxcbiMjIFRoZSBmaW5hbCBzb2x1dGlvblxcclxcblxcclxcblRoZSBiZXN0IHNvbHV0aW9uIGlzIHRvIG5hbWVzcGFjZSBhbmQgbWFrZSBzdXJlIHRoYXQgcGFyZW50IGFuZCBjaGlsZCBoYXZlIGRpZmZlcmVudCBwcm9wZXJ0eSBuYW1lcyBmb3IgdGhlaXIgcHJpdmF0ZSBhY2Nlc3MgZnVuY3Rpb25zLiBIZXJlJ3MgdGhlIGZpbmFsIHNvbHV0aW9uOlxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG4vKiBIZXJlJ3MgaG93IHlvdSBjYW4gY3JlYXRlIHRydWx5IHByaXZhdGVcXHJcXG4gICBwcm9wZXJ0aWVzIGluIEpTIGFuZCB1c2UgdGhlbSBvbiBwcm90b3R5cGUgKi9cXHJcXG5cXHJcXG4vLyBDcmVhdGVzIHByaXZhdGUgc3RvcmFnZSwgc2VjdXJlcyB3aXRoIGEga2V5LCBhbmRcXHJcXG4vLyByZXR1cm5zIGEgcHJpdmF0ZSBhY2Nlc3MgZnVuY3Rpb25cXHJcXG52YXIgcHJpdmF0ZSA9IGZ1bmN0aW9uKGtleSkge1xcclxcbiAgICB2YXIgb2JqID0ge307XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbih0ZXN0a2V5KSB7XFxyXFxuICAgICAgICBpZihrZXkgPT09IHRlc3RrZXkpIHJldHVybiBvYmo7XFxyXFxuICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgYWNjZXNzIHByaXZhdGUgcHJvcGVydGllcycpO1xcclxcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXHJcXG4gICAgfTtcXHJcXG59O1xcclxcblxcclxcbi8vIENyZWF0ZSBjbG9zdXJlXFxyXFxudmFyIFBhcmVudENsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgIHZhciBwcml2ID0gJ19QYXJlbnRDbGFzcycgKyBNYXRoLnJhbmRvbSgpOyAvLyBOYW1lc3BhY2VcXHJcXG4gICAgdmFyIGtleSA9IHt9OyAvLyBDcmVhdGUga2V5IHdpdGhpbmcgY2xvc3VyZVxcclxcbiAgICB2YXIgUGFyZW50Q2xhc3MgPSBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIHRoaXNbcHJpdl0gPSBwcml2YXRlKGtleSk7IC8vIENyZWF0ZSBwcml2YXRlIHN0b3JhZ2VcXHJcXG4gICAgICAgIHRoaXNbcHJpdl0oa2V5KS5wcml2X3Byb3AgPSAxMDA7IC8vIE1vZGlmeSBhbnkgcHJpdmF0ZSBkYXRhXFxyXFxuICAgIH07XFxyXFxuICAgIFBhcmVudENsYXNzLnByb3RvdHlwZS5wYXJlbnRfdGVzdCA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2codGhpc1twcml2XShrZXkpLnByaXZfcHJvcCk7IC8vIEFjY2VzcyBwcml2YXRlIGRhdGFcXHJcXG4gICAgfTtcXHJcXG4gICAgcmV0dXJuIFBhcmVudENsYXNzO1xcclxcbn0oKTtcXHJcXG5cXHJcXG52YXIgQ2hpbGRDbGFzcyA9IGZ1bmN0aW9uKCkge1xcclxcbiAgICB2YXIgcHJpdiA9ICdfQ2hpbGRDbGFzcycgKyBNYXRoLnJhbmRvbSgpO1xcclxcbiAgICB2YXIga2V5ID0ge307XFxyXFxuICAgIHZhciBDaGlsZENsYXNzID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICBQYXJlbnRDbGFzcy5jYWxsKHRoaXMpO1xcclxcbiAgICAgICAgdGhpc1twcml2XSA9IHByaXZhdGUoa2V5KTtcXHJcXG4gICAgICAgIHRoaXNbcHJpdl0oa2V5KS5wcml2X3Byb3AgPSAyMDA7XFxyXFxuICAgIH07XFxyXFxuICAgIENoaWxkQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcXHJcXG4gICAgICAgIFBhcmVudENsYXNzLnByb3RvdHlwZVxcclxcbiAgICApO1xcclxcbiAgICBDaGlsZENsYXNzLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24oKSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzW3ByaXZdKGtleSkucHJpdl9wcm9wKTtcXHJcXG4gICAgfTtcXHJcXG4gICAgcmV0dXJuIENoaWxkQ2xhc3M7XFxyXFxufSgpO1xcclxcblxcclxcbnZhciBpbnN0YW5jZSA9IG5ldyBDaGlsZENsYXNzKCk7XFxyXFxuaW5zdGFuY2UudGVzdCgpOyAvLyBgMjAwYCBsb2dnZWQsIGFzIGV4cGVjdGVkXFxyXFxuaW5zdGFuY2UucGFyZW50X3Rlc3QoKTsgLy8gYDEwMGAgbG9nZ2VkLCBhcyBleHBlY3RlZFxcclxcblxcclxcbi8vIFlldCwgdGhlcmUncyBubyB3YXkgdG8gYWNjZXNzIHRoZSBwcm9wZXJ0eSBmcm9tIG91dHNpZGUgb2YgdGhlIGNsb3N1cmVcXHJcXG5gYGBcXHJcXG5cXHJcXG5QcmV0dHkgbXVjaCB0aGUgb25seSBkaWZmZXJlbmNlIGZyb20gdGhlIHByZXZpb3VzIGNvZGUgc25pcHBldCBpcyB0aGF0IHdlIHJlcGxhY2VkIGB0aGlzLl9gIGZvciBib3RoIGNoaWxkIGFuZCBwYXJlbnQgY2xhc3NlcyB3aXRoIGB0aGlzW3ByaXZdYCwgd2hlcmUgYHByaXZgIGlzIG5hbWVzcGFjZWQgYW5kIHJhbmRvbWx5IGdlbmVyYXRlZCB0byBlbnN1cmUgdGhhdCBwcml2YXRlIGFjY2VzcyBmdW5jdGlvbiBpcyBzdG9yZWQgdW5kZXIgYSBkaWZmZXJlbnQgcHJvcGVydHkgbmFtZSBmb3IgY2hpbGQgYW5kIHBhcmVudC5cXHJcXG5cXHJcXG5Bbm90aGVyIHJlY29tbWVuZGF0aW9uIEkgY2FuIG1ha2UgaXMgdGhhdCB5b3Ugc2hvdWxkIHByb2JhYmx5IHNlY3VyZSBgdGhpc1twcml2XWAgYnkgbWFraW5nIGl0IG5vbi1jb25maWd1cmFibGUsIG5vbi1lbnVtZXJhYmxlIGFuZCByZWFkLW9ubHk6XFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcml2LCB7XFxyXFxuICAgIHZhbHVlOiBwcml2YXRlKGtleSlcXHJcXG59KVxcclxcbmBgYFxcclxcblxcclxcbkluc3RlYWQgb2YganVzdFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG50aGlzW3ByaXZdID0gcHJpdmF0ZShrZXkpXFxyXFxuYGBgXFxyXFxuXFxyXFxuVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGF0IHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byByZW1vdmUgb3IgbW9kaWZ5IGB0aGlzW3ByaXZdYCwgd2hpY2ggaXMgY3J1Y2lhbCBmb3IgY29ycmVjdCBwcml2YXRlIHN0b3JhZ2UgZnVuY3Rpb25pbmcuXFxyXFxuXFxyXFxuIyMgQ29uY2x1c2lvblxcclxcblxcclxcbkdvIGFoZWFkIGFuZCB1c2UgKiphY2Nlc3NvciBwYXR0ZXJuKiohIEl0IGFsbG93cyB5b3UgdG8gY3JlYXRlIHRydWx5IGVuY2Fwc3VsYXRlZCBwcm9wZXJ0aWVzIGFuZCB1c2UgdGhlbSBvbiBhIHByb3RvdHlwZS4gTGV0IG90aGVycyBrbm93IGFib3V0IHRoaXMgbWV0aG9kIHNvIHdlIGRvbid0IGNvbnRpbnVlIHRoZSBtaXNjb25jZXB0aW9uIHRoYXQgcHJpdmFjeSBpcyBpbXBvc3NpYmxlIHRvIGFjaGlldmUgaW4gSmF2YVNjcmlwdC4gU2hhcmluZyB0aGlzIGFydGljbGUgd2lsbCBhbHNvIGhlbHAgKirwn5iKKipcIjsiXSwic291cmNlUm9vdCI6IiJ9